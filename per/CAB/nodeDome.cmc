
///////////////////////////
//
// Dome control cmc script
// 6/7/01  STO
//
///////////////////////////

// REQUIRES BASIC.CMC ON SAME NODE
// abs() function

// Assumes encoder is attached to dome rotation

// ======================================
// Configuration section:
//
// Note: Modify return values below to match installation bit switch settings
//
// Note bit value with notation (1<<n) where n is bit number 0 - 7
// Combine bits with | operator ex:  ((1<<3) | (1<<4)) sets both bits 3 and 4
//
// (Connector pin # reference)
// bit  JP21(in)   JP22(out)
// ---  --------   ---------
//  0      1       1(hi) 2(lo)
//  1      3       3(hi) 4(lo)
//  2      5       5(hi) 6(lo)
//  3      7       7(hi) 8(lo)
//  4      9       9(hi) 10(lo)
//  5      11      11(hi) 12(lo)
//  6      13	   13(hi) 14(lo)
//  7      15      15(hi) 16(lo)

//---------------------------------------
// Output line switches
// Connector JP22.  "1" initiates action.

// roof/shutter
define open_the_door() 	
	{ return (1<<7); }		// output bit that initiates door open

define close_the_door()
	{ return (1<<6); }		// output bit that initiates door close

// dome
define rotate_CW()	
	{ return (1<<5); }		// output bit that initiates CW rotation
	
define rotate_CCW()	
	{ return (1<<4); }		// output bit that initiates CCW rotation

//----------------------------------------
// Input state switches
// Connector JP21.  "1" indicates 'true' status

// Define input bits for roof status
define door_status_open() 	
	{ return (1<<7); } 		// input bit that indicates door is open
	
define door_status_closed()	
	{ return (1<<6); } 		// input bit that indicates door is closed
	
define door_status_error()	
	{ return (0); } 		// if there is a separate error condition input
							// (0 if none)

// Define the home and limit input switches for dome
// If no limits, define as 0
// There MUST be a home bit defined
define dome_home_bit()
	{ return (1<<1); }		// JP21 input bit that indicates home
	
define dome_pos_limit()
	{ return (1<<5); }		// JP21 input bit that indicates end of
							// positive encoder dome rotation (0 if none)
							
define dome_neg_limit()		
	{ return (1<<4); }		// JP21 bit that indicates end of
							// negative encoder dome rotation (0 if none)


// (end of configuration section)

// ====================================

// Module variables
d = 0;	// used to define last direction during homing
s = 0;	// sign of CW encoder movement.
		// Could be preset here, or will auto set during homing if zero


////////////////////////////////////////////////////////
//
// roofseek( $action )
//   Opens dome shutter or roll-off roof
//   $action is 0 for stop, 1 for open, -1 for close
//   If roof is simply 'go' activated, use open for both
//   This will output return string of form "n: msg" where n
//   is a number <0 (error) >0 (working) or 0 (success)
//   and msg is a descriptive message of the status.
//
/////////////////////////////////////////////////////////
define roofseek( $action )
{
	
	// figure bitmask for opening/closing
	$0 = 255 ^ (open_the_door() | close_the_door());
	// mask current olevel
	$0 = olevel & $0

	// always stop first
	olevel = $0;
	
	pause(1000); // wait a second...

				
	if($action > 0) {		// open the roof or shutter
		olevel = $0 | open_the_door();
	}
	
	else if($action < 0) {	// close the roof or shutter
		olevel = $0 | close_the_door();
	}
		
	pause(200);	// wait a bit for this to register (if it needs to)
	
	
	// return status of door
	
	// get bitmask
	$2 = door_status_open() | door_status_closed() | door_status_error();
	
	$1 = iedge & $2;	// read latch
	iedge = $2;			// reset latch
	
	if($1 == door_status_open()) {
	 	if($action == 1) {
			printf("0: Door Opened");
			olevel = $0; // turn off motor
		}
		else
			printf("1: Door Open, Closing");
	}
	else if($1 == door_status_closed()) {
		if($action == 0) {
			printf("0: Door Closed");
			olevel = $0; // turn off motor
		}
		else
			printf("1: Door Closed, Opening");
	}
	
	if($1 & door_status_error() != 0) {
		olevel = $0; // stop!
		printf(-1: Error with door");
	}
	else printf("2: In Motion");
				
}

/////////////////////////////
//
// Emergency stop
//
/////////////////////////////
define roofestop()
{
	olevel &= 255 ^ (open_the_door() | close_the_door());
	dome_stop();
}

/////////////////////////////
//
// Basic dome movement functions
//
/////////////////////////////
define dome_stop()
{
	// stop dome motors
	olevel &= 255 ^ (rotate_CW() | rotate_CCW());
	
	// wait for motion to cease
	do {
		$1 = epos;
		pause(500);
	} while($1 != epos);
}

define dome_CW()
{
	dome_stop();
	
	$0 = 255 ^ (rotate_CW() | rotate_CCW());
	$0 = olevel & $0;
	
	olevel = $0 | rotate_CW();
}	

define dome_CCW()
{
	dome_stop();
	
	$0 = 255 ^ (rotate_CW() | rotate_CCW());
	$0 = olevel & $0;
	
	olevel = $0 | rotate_CCW();
}	


/////////////////////////////////////////////////////////
//
// finddomehomes()
//   Rotates dome to home position
//   This will output a return string of form "n: msg" where n
//   is a number <0 (error) >0 (working) or 0 (success)
//   and msg is a descriptive message of the status.
//
/////////////////////////////////////////////////////////
define finddomehomes()
{
  // Motion bitmask
  $0 = 255 ^ (rotate_CW() | rotate_CCW());
  $0 = olevel & $0;
	
  dome_stop();
	
  if(s != 0) printf("1: Finding Home");
	
  while(1) {
		
	// FIRST ITERATION
	// If we haven't figured out our direction sign before, do that now
	if(!s) {
	
		printf("1: Setting Sign");
		
		$2 = epos;
		
		// go for a short while, or until we hit a limit
		if(!(iedge & dome_pos_limit()) && !(iedge & dome_neg_limit()))
		{
			if(d >= 0)
				dome_CW();
			else
				dome_CCW();
		}				
		$1 = clock;
		while((clock - $1 < 1000) && ((iedge & (dome_pos_limit() | dome_neg_limit())) == 0))
		{ };
		olevel = $0; // stop;
		
		// see which direction we moved
		s = epos > $2 ? 1 : epos < $2 ? -1 : 0;			
		
		// keep in this direction, (which is CW if we didn't repeat)
		if(!d) d = 1;
		// if we hit a limit though, go other direction (CCW)
		if(iedge & (dome_pos_limit() | dome_neg_limit()))
			d = -d;
		
		// if we were at a limit to start with, s==0 and this will repeat in opposite direction
		if(s != 0) printf("1: Finding Home");
				
	}
	else // NORMAL iteration
	{			
		// which direction are we going
		if(d > 0)
			dome_CW();
		else
			dome_CCW();

		pause(200);
				
		// reverse direction if we hit limit
		if(iedge & (dome_pos_limit() | dome_neg_limit())) {
			olevel = $0;				
			d = -d;
		}

		// See if we've tripped our bit
		if(iedge & dome_home_bit()) {
						
			printf("2: Hit...");
			
			// repeat until we are better nailed to true home
			$2 = 4000;
			while($2) {	
			
				printf("2: Reversing...);		
				
				iedge = dome_home_bit() | dome_pos_limit() | dome_neg_limit();
				dome_stop();		// stop
				d = -d;				// reverse direction
				if(d > 0)
					dome_CW();
				else
					dome_CCW();
					
				$3 = clock;
				$4 = epos;			
				while(clock - $3 < $2) {
					if(iedge & dome_home_bit()) {
						printf("2: Hit...");
						break;
					}
					if(iedge & (dome_pos_limit() | dome_neg_limit())) break;
				}
				if(iedge & (dome_pos_limit() | dome_neg_limit())) break;
				if(epos == $4) break;
				
				$2 /= 2;
			}
			dome_stop(); // final stop
			
			if(iedge & (dome_pos_limit() | dome_neg_limit())) {
				// report error
				printf("-1: Limit reached during homing pass 2");
				return;
			}
			
			// set home positions and
			// report success if so
			epos = 0;
			printf("0: Dome is Home");
			return;
		}			
					
	}
		
	// reset latch
	iedge = dome_pos_limit() | dome_neg_limit() | dome_home_bit();
	
  } // repeat until we get there or hit error..

}	

	
/////////////////////////////////////////////////////////
//
// domeseek($target, $tol)
//   Move dome so encoder is at $target +/- $tol
//   This will return string of form "n: msg" where n
//   is a number <0 (error) >0 (working) or 0 (success)
//   and msg is a descriptive message of the status.
//
// (CSIMC manual, ECD)
//
/////////////////////////////////////////////////////////
	
define domeseek($target, $tol)
{
	if(!s) {
		printf("-1: No sign defined. Home Dome first.");
	}
	
	$0 = epos;					// previous encoder position
	$1 = s*(epos - $target);	// previous error
	$4 = 0;						// count loops stopped to check for stuck

	printf("1: Dome Seeking %d",$target);
		
	// loop until tolerance or detect stuck
	while(1) {
		pause(200);
		$2 = epos - $target;	// error now
		$2 *= s;				// adjust according to our movement sign (CW = positive = 1)
		$3 = epos - $0;			// movement since last time
		if(abs($2) <= $tol) {	// if in tolerance
			if($3 == 0) {		//    if stopped, done
				printf("0: Dome moved to %d",$target);
				return;		
			}
			dome_stop();		//     otherwise stop
		} else {				// otherwise, not in tolerance
			if($3 == 0) {		// if stopped
		      if(++$4 > 5)		// see if we're stuck
		      	break;
		      if($2 < esteps/2) // if stopped CW of target
		      	dome_CCW();		// go CCW
		      else
		        dome_CW();		// else go CW
		    } else {			// if not stopped
		    	$4 = 0;			//  then we're not stuck
		    	if(abs($2) > abs($1))	// if going wrong way
		    		dome_stop();	// stop
		    }
		}
		
		$0 = epos;						// update position
		$1 = s * (epos - $target);  	// update error (sign adjusted)
		      	
	}
	
	// got here on break... dome is stuck.
	printf("-1: Dome appears to be stuck");
}
		
/////////////////////////////////////////////
//
// Move the dome in a given direction
//
// Intended for use with paddle code
//
////////////////////////////////////////////

define domejog($dir)
{
	$0 = 255 ^ (rotate_CW() | rotate_CCW());
	$0 = olevel & $0;
	
	if($dir > 0)
		olevel = $0 | rotate_CW();	
	else if($dir < 0)
		olevel = $0 | rotate_CCW();
	else
		olevel = $0;		
		
}				
