#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>
#include <time.h>

#include <Xm/Xm.h>
#include <Xm/TextF.h>

#include "strops.h"
#include "telenv.h"
#include "xtools.h"

#include "mksch.h"

static void composeSched (FILE *fp);
static void getKV (KV *kvp);

/* gather the widgets (while ye may?) and write a .sch file.
 * N.B. we assume testSched() has already blessed it.
 */
void
writeSched ()
{
	char fn[1024];
	char *dir, *id;
	FILE *fp;
	int i;

	/* get directory and id */
	getKV(&kv[11]);
	dir = kv[11].str;
	getKV(&kv[2]);
	id = kv[2].str;

	/* find a new file name */
	for (i = 0; i < 999; i++) {
	    sprintf (fn, "%s/%s%03d.sch", dir, id, i);
	    fp = telfopen (fn, "r");
	    if (!fp)
		break;
	    (void) fclose (fp);
	}

	/* open for write */
	fp = telfopen (fn, "w");
	if (!fp) {
	    msg ("%s: %s", basenm(fn), strerror(errno));
	    return;
	}

	/* write */
	composeSched (fp);
	msg ("%s: written ok", basenm(fn));

	/* finished */
	fclose (fp);
}

/* test the current schedule design.
 * return 0 if ok, else -1
 */
int
testSched ()
{
	char *tnm = tmpnam(NULL);
	char buf[1024];
	FILE *fp;
	int status;

	/* check that id has no blanks */
	getKV(&kv[2]);
	if (strchr (kv[2].str, ' ')) {
	    msg ("ID must not contain blanks");
	    return (-1);
	}

	/* build the schedule from the GUI */
	fp = fopen (tnm, "w");
	if (!fp) {
	    msg ("Could not make temp file: %s", strerror(errno));
	    return (-1);
	}
	composeSched(fp);
	fclose (fp);

	/* check it with chksch -- only no output is ok */
	sprintf (buf, "chksch %s 2>&1", tnm);
	status = 0;
	fp = popen (buf, "r");
	if (fp) {
	    if (fgets (buf, sizeof(buf), fp)) {
		/* strip off leading file name and trailing \n */
		char *start = strchr(buf, ':') + 2;
		msg ("%.*s", strlen(start)-1, start);
		status++;
	    } else
		msg ("Schedule is Good");
	    pclose (fp);
	} else {
	    msg ("Error checking schedule");
	    status++;
	}

	/*
	remove (tnm);
	*/

	return (status == 0 ? 0 : -1);
}

/* read the widgets and write a schedule onto fp.
 */
static void
composeSched (FILE *fp)
{
	time_t t;
	int i;
	int br;

	/* gather all the fields */
	for (i = 0; i < nkv; i++)
	    getKV(&kv[i]);

	time (&t);
	fprintf (fp, "! Generated by mksch Version %s\n", version);
	fprintf (fp, "! By Observer ID %s\n", kv[2].str);
	fprintf (fp, "! On UTC %s\n", asctime(gmtime(&t)));
	fprintf (fp, "\n");
	fprintf (fp, "TITLE = '%s'\n", kv[0].str);
	fprintf (fp, "OBSERVER = '%s'\n", kv[1].str);
	fprintf (fp, "\n");

	br = atoi(kv[20].str);
	if (br > 1)
	    fprintf (fp, "BLOCK = '%s'\n", kv[19].str);

	fprintf (fp, "    SOURCE = '%s'\n", kv[4].str);
	if (strlen(kv[5].str))
	    fprintf (fp, "    RA = '%s'\n", kv[5].str);
	if (strlen(kv[6].str)) {
	    fprintf (fp, "    DEC = '%s'\n", kv[6].str);
	    fprintf (fp, "    EPOCH = 2000\n");
	}

	fprintf (fp, "    FILTER = '%s'\n", kv[7].str);
	fprintf (fp, "    DURATION = '%s'\n", kv[8].str);
	if (strlen(kv[9].str))
	    fprintf (fp, "    BINNING = '%s'\n", kv[9].str);
	if (strlen(kv[10].str))
	    fprintf (fp, "    SUBIMAGE = '%s'\n", kv[10].str);

	if (strlen(kv[13].str))
	    fprintf (fp, "    LSTDELTA = '%s'\n", kv[13].str);
	if (strlen(kv[15].str))
	    fprintf (fp, "    HASTART = '%s'\n", kv[15].str);
	if (strlen(kv[16].str))
	    fprintf (fp, "    LSTSTART = '%s'\n", kv[16].str);
	if (strlen(kv[17].str))
	    fprintf (fp, "    PRIORITY = %s\n", kv[17].str);
	if (strlen(kv[14].str))
	    fprintf (fp, "    COMPRESS = %s\n", kv[14].str);
	if (strlen(kv[12].str))
	    fprintf (fp, "    IMAGEDIR = '%s'\n", kv[12].str);
	if (strlen(kv[3].str))
	    fprintf (fp, "    COMMENT = '%s'\n", kv[3].str);
	if (strlen(kv[18].str))
	    fprintf (fp, "    REPEAT = %s\n", kv[18].str);
	fprintf (fp, "    /\n");

	if (br > 1)
	    fprintf (fp, "BLOCKREPEAT = %d\n", br);
}

static void
getKV (KV *kvp)
{
	if (kvp->str)
	    XtFree (kvp->str);
	kvp->str = XmTextFieldGetString (kvp->w);
}

