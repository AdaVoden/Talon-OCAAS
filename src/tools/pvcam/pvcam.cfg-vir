# read by pvcam to set local options
# 0.5m camera

# set $traceon to 1 if want trace info
$traceon = 1;
$verboseTrace = 1;

# Camera ID string
$id = "Virtual PVCamera";

$truew = 1600; # 4096;   	# true size of camera
$trueh = 1600; # 4096;

$imw = 512;		# size of center section to return to camera	
$imh = 512;

# Pre-orient options for Mosaic
# turn over upside-down PV image
# do as two sections so we can do adjustments
# for best astrometric fit between chips
$orient = "-r 0 0 800 1600 turnOver 800 0 -r 800 0 800 1600 turnOver 0 0"; # "-r 0 0 2048 4096 turnOver 2048 0 -r 2048 0 2048 4096 turnOver 0 0";

# Cutting options
# definitions of area to cut for each component
# starting with number 1
$xywhdef[1] = "800 0 800 1600";	# "2048 0 2048 4096";
$xywhdef[2] = "0 0 800 1600"; # "0 0 2048 4096";

# suffix strings for each section
# as a comma-delimited string of names
# note that section 00 is return section
$sectionNames = "center,e1,e2";

# names for temporary calibration files
$biasName = "bias";
$thermName = "therm";
$flatName = "flat";

# set to 0 to disable all post-process steps
$enablePostProcessing = 1;

# ==========================

# fake temperature
$faketemp = -100;

$maxbx = 2;		# 3 causes pv software to choke
$maxby = 2;

# trigger LP bits
$lpshut = 0x1;		# LP data bit to activate Shutter
$lptrig = 0x2;		# LP data bit to activate Trigger

# how to run the lpio command
# and the stampfits command
if (1) { # `uname -n` eq "halfm\n") {
    $lpiocmd = "#"; 					# "lpio";
    $stampcmd = "stampfits";
    $mosaicCmd = "mosaic";              # "rsh datar3 mosaic";
    $pipelnCmd = "pipeline";            # "rsh datar3 pipeline";
} else {
    $lpiocmd = "rsh halfm lpio";
    $stampcmd = "rsh halfm stampfits";
    $mosaicCmd = "mosaic";
    $pipelnCmd = "pipeline";
}

# shared file base dir, setup, go, done and result file
$sfb = "/home/steve/test";  #"/mdo/filewait";
$sfset = "$sfb/in/settings.reg";
$sfshadow = "$sfb/in/settings.shadow";
$sfgo = "$sfb/in/fit16snp";
$sfim = "$sfb/out/fitout.fit";
$sferr = "$sfb/out/error.txt";
$sfcancel = "$sfb/in/cancel";

$base = "/home/steve/test/base"; #"/mdo/user/images";	# base name and path for output files

$fitsnow = "$TELHOME/archive/fitsnow";  # temp file for placeholder fits header

# timeouts
$dlto = 90;		# time for camera to download image
$lanto = 40;		# max time to get image over lan

# err and trace log
$elog = "$TELHOME/archive/logs/pvcam.log";


# ---------------------
# stsci stuff
$url = "http://stdatu.stsci.edu/cgi-bin/dss_search";
$survey = 1;
$harcmin = 35.3333;
$varcmin = 35.3333;

#
# Format the request for use with STScI
#
sub formatURLRequest()
{
    $rah    = $_[0];
    $ram    = $_[1];
    $ras    = $_[2];
    $dcd    = $_[3];
    $dcm    = $_[4];
    $dcs    = $_[5];
    $pixW   = $_[6];
    $pixH   = $_[7];
    $filter = $_[8];

    # DSS-1 has no filter (clear only)
    # determine survey according to filter
    $survey = "1";         # DSS-I (clear)

    if($pixW > 1000) {$pixW++;}
    if($pixH > 1000) {$pixH++;}
	# frame request
	my $hminrq = $pixW / $harcmin ;  #/ arc minutes horizontal requested
	my $vminrq = $pixH / $varcmin;  #/ arc minutes vertical requested

	my $rqst = sprintf("%s?v=%s&r=%02d+%02d+%02d&d=%02d+%02d+%02d&e=J2000&h=%.2f&w=%.2f&f=fits&c=none&fov=NONE&v3=",
   		               $url,$survey,$rah,$ram,$ras,$dcd,$dcm,$dcs,$vminrq,$hminrq);

}
