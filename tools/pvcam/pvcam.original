#!/usr/bin/perl
# operate a PixelVision camera via shared file interface.
# get params from $TELHOME/archive/config/pvcam.cfg
# send errors to $TELHOME/archive/logs/pvcam.log
# see &usage() for command summary.

# get parameters
$TELHOME = $ENV{TELHOME};
do "$TELHOME/archive/config/pvcam.cfg";

# set $traceon to 1 if want trace info
$traceon = 1;

# sync output
$| = 1;

# get command
$cmd = (@ARGV > 0 and $ARGV[0] =~ /^-[^h]/) ? $ARGV[0] : &usage();

# return current temp
if ($cmd eq "-T") {
    &errlog ("@ARGV") if @ARGV != 1;
    print "$faketemp\n";
    exit 0;
}

# return maxen
if ($cmd eq "-f") {
    &errlog ("@ARGV") if @ARGV != 1;
    print "$imw $imh $maxbx $maxby\n";
    exit 0;
}

# -g: check exp args
if ($cmd eq "-g") {
    &errlog ("@ARGV") if @ARGV != 2;
    my ($x,$y,$w,$h,$bx,$by,$shtr) = split (/:/, $ARGV[1]);
    if ($x != 0 or $y != 0 or $w != $imw or $h != $imh) {
	print ("Subframing is not supported\n");
	exit 1;
    }
    if ($bx < 1 || $bx > $maxbx) {
	print ("X binning must be 1..$maxbx\n");
	exit 1;
    }
    if ($by < 1 || $by > $maxby) {
	print ("Y binning must be 1..$maxby\n");
	exit 1;
    }
    if ($shtr < 0 || $shtr > 3) {
	print ("Shtr must be 0..3\n");
	exit 1;
    }
    exit 0;
}

# camera id string
if ($cmd eq "-i") {
    &errlog ("@ARGV") if @ARGV != 1;
    print "$id\n";
    exit 0;
}

# kill exposure. can't really, but at least remove trigger file
if ($cmd eq "-k") {
    &errlog ("@ARGV") if @ARGV != 1;
    unlink($sfgo);
    print "Can not stop PV expose\n";
    exit 1;
}

# open or close shutter
if ($cmd eq "-s") {
    &errlog ("@ARGV") if @ARGV != 2;
    &shutter ($ARGV[1]);
    exit 0;
}

# -x: start exp, hang around until get image, send 1 byte when see something,
# rest of file to stdout, then exit.
# N.B. any error messages should have extra leading char.
if ($cmd eq "-x") {
    &errlog ("@ARGV") if @ARGV != 2;
    my ($ms,$x,$y,$w,$h,$bx,$by,$shtr) = split (/:/, $ARGV[1]);

    # sanity check parameters
    if ($x != 0 or $y != 0 or $w != $imw or $h != $imh) {
	print ("Subframing is not supported\n");
	exit 1;
    }
    if ($bx > $maxbx or $by > $maxby) {
	print ("Binning too high\n");
	exit 1;
    }

    &setupExp ($ms, $bx, $by);		# set new camera parameters 
    sleep 1;				# allow time to save in registry
    unlink ($sfim);			# remove image file
    &touch($sfgo);			# create file to signal start exposure
    sleep 1;				# allow time to absorb
    &doExposure ($shtr, $ms);		# control shutter, return in $ms
    print "\n";				# one dummy char to signal end of exp
    &w4file($sfim, $dlto);		# wait for image file to start to appear
    my $sz = $w/$bx*$h/$by*2;		# expected number of bytes for pixels
    &rdImFile($sfim, $sz);		# then copy image to EOF
    exit 0;
}

# print usage summary and exit
sub usage
{
    my $me = $0;
    $me =~ s#.*/##;
    print "Usage: $me {options}\n";
    print "Purpose: operate a PV camera from OCAAS via share file interface\n";
    print "Options:\n";
    print " -g x:y:w:h:bx:by:shtr      test if given exp params are ok\n";
    print " -x ms:x:y:w:h:bx:by:shtr   start the specified exposure\n";
    print "                            shtr: 0=Close 1=Open 2=OOCO 3=OOCOCO\n";
    print " -k                         kill current exp, if any\n";
    print " -t temp                    set temp to given degrees C\n";
    print " -T                         current temp on stdout in C\n";
    print " -s open                    immediate shutter open or close\n";
    print " -i                         1-line camera id string on stdout\n";
    print " -f                         max `w h bx by' on stdout\n";

    exit 1;
}

# create a file
sub touch
{
    my $fn = $_[0];
    open F, ">$fn" or print EL " Can not create $fn: $!\n";
    close F;
}

# wait for the given file to exist
sub w4file
{
    my $fn = $_[0];
    my $to = $_[1];
    my $begto = $to;
    my $etime;

    &trace ("Waiting $to secs for $fn");

    while (!open (F, "<$fn")) {
	&errlog ("$fn: timeout waiting to appear") if ($to-- == 0);
	sleep 1;
    }
    $etime = $begto - $to;
    &trace ("File appeared in $etime seconds") if ($to > 0);
    close F;
}

# copy image pixels from file to stdout.
# N.B. be patient, it might still be coming in
# N.B. skip the header
sub rdImFile
{
    my $fhdr = 2880;			# bytes in FITS header 
    my $fn = $_[0];			# file name
    my $sz = $_[1] + $fhdr;		# bytes including header
    my $nrd = 0;
    my $buf;
    my $tot;

    &trace ("Waiting $lanto secs for $fn to be $sz");
    # wait for file to completely arrive */
    for ($tot = 0; $tot < $lanto; $tot++) {
	my $fnsz = -s $fn;
	&trace ("$tot/$lanto: $fnsz/$sz");
	last if ($fnsz >= $sz);
	sleep 1;
    }
    $tot < $lanto or &errlog("$fn: timeout waiting for complete");

    # skip FITS header
    &trace ("skipping FITS header");
    open F, "<$fn" or &errlog ("$fn: $!");
    for ($tot = 0; $tot < $fhdr; $tot += $nrd) {
	$nrd = read (F, $buf, $fhdr - $tot);
	&errlog ("$fn: $!") if (!defined($nrd));
    }

    # all the rest are pixels
    &trace ("sending pixels after skipping $tot");
    for (; $tot < $sz; $tot += $nrd) {
	$nrd = read (F, $buf, 16384);
	&errlog ("$fn: $!") if (!defined($nrd));
	&errlog ("Bad print @ $tot/$sz") unless print $buf;
    }

    close F;

    # ccdcamera lib kills us when gets all pixels so ok if never see this
    &trace ("$fn complete");
}

# this function operates the shutter for a given duration/mode exposure.
# the camera has already been armed for an exposure in trigger mode.
# return when the exposure is complete.
sub doExposure
{
    my $shtr = $_[0];	# mode
    my $ms = $_[1];		# ms

    &trace ("doExp: $ms ms, shtr code $shtr");

    if ($shtr == 0) {
	# closed for the entire time
	&shutter(0);
	&trigger(1);
	&mssleep ($ms < 3 ? 3 : $ms);	# 0 dur never seems to work
	&shutter(0);
	&trigger(0);
    } elsif ($shtr == 1) {
	# open the entire time
	&shutter(1);
	&trigger(1);
	&mssleep ($ms);
	&shutter(0);
	&trigger(0);
    } elsif ($shtr == 2) {
	# Dbl: OOCO
	&shutter(1);
	&trigger(1);
	&mssleep ($ms/2);
	&shutter(0);
	&mssleep ($ms/4);
	&shutter(1);
	&mssleep ($ms/4);
	&shutter(0);
	&trigger(0);
    } elsif ($shtr == 3) {
	# Mutli: OOCOCO
	&shutter(1);
	&trigger(1);
	&mssleep ($ms/3);
	&shutter(0);
	&mssleep ($ms/6);
	&shutter(1);
	&mssleep ($ms/6);
	&shutter(0);
	&mssleep ($ms/6);
	&shutter(1);
	&mssleep ($ms/6);
	&shutter(0);
	&trigger(0);
    } else {
	&errlog ("Bad shutter: $shtr");
    }

    &trace ("Exp complete");
}

# tell camera the new settings
sub setupExp
{
    my $ms = $_[0];
    my $bx = $_[1];
    my $by = $_[2];

    &trace ("setupExp: $ms ms, $bx X $by");

    open SFN, ">$sfset" or &errlog ("$sfset: $!");
    print SFN "REGEDIT4\r\n";
    print SFN "\r\n";
    print SFN "[HKEY_LOCAL_MACHINE\\SOFTWARE\\PixelVision\\PixelView\\3.2\\Library\\settings]\r\n";
    printf SFN "\"Exposure Time\"=dword:%08x\r\n", $ms;
    printf SFN "\"Bin X Size\"=dword:%08x\r\n", $bx;
    printf SFN "\"Bin Y Size\"=dword:%08x\r\n", $by;
    close SFN;

    # wait for file to disappear
    my $to;
    for ($to = 0; $to < 10; $to++) {
	if (open X, "<$sfset") {
	    close X;
	    return;
	}
	sleep 1;
    }
    &errlog ("$sfset: did not disappear");
}

sub mssleep
{
	my $ms = $_[0];
	select (undef, undef, undef, $ms/1000.);
}

sub shutter
{
	my $open = $_[0];
	my $cmd;

	if ($open > 0) {
	    $cmd = "$lpiocmd -1 $lpshut";
	} else {
	    $cmd = "$lpiocmd -0 $lpshut";
	}
	system ("$cmd");
	&trace ("$cmd");
}

sub trigger
{
	my $start = $_[0];
	my $cmd;

	if ($start > 0) {
	    $cmd = "$lpiocmd -0 $lptrig";
	} else {
	    $cmd = "$lpiocmd -1 $lptrig";
	}
	system ("$cmd");
	&trace ("$cmd");
}

# append $_[0] to STDOUT and timestamp + $_[0] to $elog and exit
sub errlog
{
	print " $_[0]";
	open EL, ">>$elog";
	$ts = `jd -t`;
	print EL "$ts: $_[0]\n";
	close EL;
	exit 1;
}

# if $trace: append $_[0] to $elog
sub trace
{
	return unless ($traceon);
	open TL, ">>$elog";
	$ts = `jd -t`;
	print TL "$ts: $_[0]\n";
	close TL;
}

# For RCS Only -- Do Not Edit
# @(#) $RCSfile: pvcam.original,v $ $Date: 2003/04/15 20:48:39 $ $Revision: 1.1.1.1 $ $Name:  $
